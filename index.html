<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Marker Display</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // Function to get query parameters
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return JSON.parse(decodeURIComponent(params.get('data')));
        }

        // Initialize the map
        const params = getQueryParams();
        const map = L.map('map').setView([22.0, 114.0], 13);

        // Set tile layer based on query parameter
        const tileLayerUrl = params.tile == "NO_LABELS_LIGHT_THEME" ?
            "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png" :
            "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

        L.tileLayer(tileLayerUrl, {
            maxZoom: params.tile == "NO_LABELS_LIGHT_THEME" ? 24 : 19,
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Icon mapping
        const iconMap = {
            USER: "ÂúñÂ∫´/icons8-adventurer-64.png",
        };

        // Create an array to hold marker bounds and circles
        const markers = [];
        const randomIndices = new Set(); // Using a Set to avoid duplicates

        // Fetch `questionNotice` from the API
        async function fetchQuestionNotice() {
            try {
                const response = await fetch("https://mcq-webapp-nodejs.vercel.app/api/service/GetConfiguration?ÂêçÁ®±=ÂïèÈ°åÊåáÁ§∫ÁâåÊï∏Èáè");
                if (!response.ok) throw new Error('Network response was not ok');
                const result = await response.json();
                return result.data.split(',').map(e=>parseInt(e));
            } catch (error) {
                console.error('Error fetching questionNotice:', error);
                return 0; // Return 0 if there is an error
            }
        }

        // Main function to initialize the map and markers
        async function initMap() {
            const questionNoticeList = await fetchQuestionNotice(); // Await the fetch
			console.log(JSON.stringify(questionNoticeList,null,4))

            // Add markers based on geoinfo
            params.geoinfo.split('@').forEach((info, index) => {
                let [type, lat, lng, accuracy] = info.split(',');
                [lat, lng, accuracy] = [parseFloat(lat), parseFloat(lng), parseFloat(accuracy)];

                // Determine the icon URL
                const iconUrl = type === 'U'
                    ? iconMap.USER
                    : "ÂúñÂ∫´/icons8-question-64.png"; // Default icon for Q_n types

                // Add marker to the map
                const marker = L.marker([lat, lng], {
                    icon: L.icon({
                        iconUrl: iconUrl,
                        iconSize: [32, 32], // Adjust the size as needed
                        iconAnchor: [16, 32],
                        popupAnchor: [0, -32]
                    })
                }).addTo(map);

                const popupContent = `${type != 'U' ? `üí° ÂïèÈ°å ${questionNoticeList.includes(index) || params.get('usage') == "ADMIN" ? type.slice(1) : "***"}` : `ü§† Áî®Êà∂`}<br/>Ë™§Â∑ÆÔºö${accuracy} Á±≥`;
                marker.bindPopup(popupContent);

                // Add click event to marker
                marker.on('click', () => {
                    // Remove any previously drawn circles
                    map.eachLayer(layer => {
                        if (layer instanceof L.Circle) {
                            map.removeLayer(layer);
                        }
                    });

                    // Draw a circle around the marker
                    const circle = L.circle([lat, lng], {
                        radius: accuracy, // Set the radius corresponding to accuracy
                        color: 'blue',
                        fillColor: '#30f',
                        fillOpacity: 0.5
                    }).addTo(map);
                });

                // Add the marker's position to the markers array
                markers.push(marker.getLatLng());
            });

            // Fit the map bounds to include all markers
            if (markers.length > 0) {
                const group = L.latLngBounds(markers);
                map.fitBounds(group);
            }
        }

        // Initialize the map and markers
        initMap();
    </script>
</body>

</html>
